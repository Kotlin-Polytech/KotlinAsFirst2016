= 6. Простые классы

__Классы__ придуманы программистами в первую очередь для структурирования данных.
Мы с вами уже видели, что в более-менее сложных задачах часто бывает необходимо использование составных типов -- 
таких, как списки или строки;
кстати говоря, и список и строка тоже являются __классами__, но только классами, определёнными в библиотеке языка.

Списки, однако, ограничены использованием элементов одного типа.
Кроме этого, доступ к элементам в них происходит по номеру, что не всегда удобно.
Рассмотрим, например, простую задачу вычисления расстояния между точками `p1` и `p2`:

[source,kotlin]
----
fun distance(x1: Double, y1: Double, x2: Double, y2: Double) = sqrt(sqr(x2 - x1) + sqr(y2 - y1))
----

Сразу же бросается в глаза, что в условии задачи мы говорили о двух точках, 
а в заголовке функции имеем вместо этого четыре параметра, по два для каждой из точек.
Гораздо понятнее было бы иметь функцию в таком виде:

[source,kotlin]
----
fun distance(p1: Point, p2: Point) = ...
----

Можно ли так написать заголовок функции? Да, конечно! 
Но для этого придётся определить в программе тип `Point`.
В Котлине, самый простой способ это сделать выглядит так:

[source,kotlin]
----
class Point(val x: Double, val y: Double)

fun distance(p1: Point, p2: Point) = sqrt(sqr(p2.x - p1.x) + sqr(p2.y - p1.y))
----

Строчка `class Point(...)` определяет новый __класс__.
Такое определение всегда начинается с ключевого слова **class**, за которым следует __имя__ класса. 
Имена классов формируются по обычным правилам; 
не забывайте, что их рекомендуется начинать с прописной буквы -- в отличие от имён переменных и функций.

== Конструкторы и свойства класса

В круглых скобках перечисляется, какие данные необходимы для создания новой точки.
Создание новой точки -- это функция, но функция специальная -- __конструктор__.
Поэтому и параметры этой функции определяются почти (но не совсем) так же, как и для обычной функции.
В данном случае мы видим, что создания точки необходимо задать её вещественные координаты `x` и `y`.

Внимательный читатель заметит отличие в определении `x` и `y` от обычных параметров функции -- 
оно заключается в добавлении ключевого слова **val** перед именем каждого параметра.
Ключевое слово **val** перед параметром __конструктора__ превращает его из простого параметра в __свойство__ класса.
__Свойства__ в данном случае задают внутреннюю структуру каждой точки.
Свойство, заданное через **val**, можно читать, используя имя переменной (или параметра) типа `Point` и символ точки: `p1.x`.
Вместо **val** можно использовать **var** (мутирующее свойство), тогда свойство можно будет также изменять: `p1.x = ...`.
Обращение к свойству напоминает вызов функции, имеющей получателя, но в нём отсутствуют круглые скобки и набор аргументов.
В этом месте можно вспомнить и понять, что `list.size` является свойством списка (размер), а `str.length` -- свойством строки (длина).

Итак, каждая наша точка имеет два свойства -- `x` и `y`.
Обратите внимание, что, определив класс, мы определили и тип, но не определили ни одной переменной данного типа.
Создаются новые точки следующим простым образом:

[source,kotlin]
----
fun usePoints() {
    // Здесь мы просто перечисляем аргументы
    val a = Point(0.0, 3.0)
    // А здесь перед каждым аргументом мы написали имя параметра, которому он соответствует
    val b = Point(x = 4.0, y = 0.0)
    println(distance(a, b)) // 5.0
}
----

Каждый вызов __конструктора__ `Point` создаёт новую точку, или __объект__ (синоним -- __экземпляр__) класса `Point`.
Вызов `distance(a, b)` рассчитывает расстояние между двумя созданными точками.

== Функции класса

Определение класса `Point`, приведённое в начале этого раздела, было пустым.
Это означает, что класс содержит только два свойства `x` и `y`.
Немного изменим определение класса, перенеся функцию `distance` внутрь него.
Программисты называют такие функции __членами класса__.

[source,kotlin]
----
class Point(val x: Double, val y: Double) {
    fun distance(other: Point): Double = sqrt(sqr(x - other.x) + sqr(y - other.y))
}
----

Такая функция вместо двух параметров имеет лишь один -- точку `other` (другая).
Однако определённая внутри класса функция имеет также __получателя__
(мы уже сталкивались с такими функциями ранее, но ни разу не определяли их сами).
__Получатель__ функции -- объект того класса, членом которого является данная функция.
Например:

[source,kotlin]
----
fun usePoints() {
    val a = Point(0.0, 3.0)
    val b = Point(4.0, 0.0)
    println(a.distance(b)) // 5.0
}
----

Здесь точка `a` стоит перед именем функции и используется функцией как получатель.
Аргумент `b` используется как параметр `other`.
Как результат, функция `distance` всё равно имеет доступ к двум точкам.
Она работает с получателем, непосредственно используя свойства своего класса-владельца: `x` и `y`.
Также она работает с параметром, используя его свойства как `other.x` и `other.y`.

== Сравнение объектов класса на равенство

Как нам уже известно, на равенство `==` можно сравнивать не только числа, но и переменные более сложных типов,
например, строки или списки.
Часто необходимо уметь сравнить на равенство переменные с типом, определённым пользователем в виде __класса__.
Например, в группе задач `lesson6.task2` про шахматную доску и фигуры имеется класс `Square`,
описывающий одну клетку шахматной доски.
В наиболее простой форме он выглядел бы так:

[source,kotlin]
----
class Square(val column: Int, val row: Int)
----

Проверим, что будет, если сравнить две одинаковых клетки `first` и `second` на равенство:

[source,kotlin]
----
fun main(args: Array<String>) {
    val first = Square(3, 6)
    val second = Square(3, 6)
    println(first == second)
}
----

Если запустить эту главную функцию, мы увидим на консоли результат `false`. Почему?

Всё дело в способе работы, принятом в JVM для любых объектов.
Каждый раз, когда мы вызываем конструктор какого-либо класса, в динамической памяти JVM создаётся объект этого класса.
Ссылка на него запоминается в стеке JVM (подробности будут в разделе 4.5).
По умолчанию, при сравнении объектов на равенство сравниваются друг с другом ССЫЛКИ, а не содержимое объектов.

Немного изменим определение класса `Square`, добавив впереди модификатор `data`.
Такое определение обычно читается как "класс с данными".

[source,kotlin]
----
data class Square(val column: Int, val row: Int)
----

Запустив главную функцию ещё раз, мы увидим результат `true`.
При наличии модификатора `data`, для объектов класса работает другой способ сравнения на равенство:
все свойства первого объекта сравниваются с соответствующими свойствами второго.
Поскольку для обоих объектов `column = 3` и `row = 6`, данные объекты равны.

Помимо этой возможности, классы с данными позволяют представить объект в виде строки, например:

[source,kotlin]
----
fun main(args: Array<String>) {
    val first = Square(3, 6)
    println(first)
}
----

Эта функция выведет на консоль `Square(x=3, y=6)`.
Попробуйте теперь убрать модификатор `data` в определении класса и посмотрите, как изменится вывод.
Заметим, что строковое представление используется не только при выводе на консоль, но и в отладчике.

Каким же образом осуществляется переопределение способа сравнения объектов и способа их представления в виде строки?
Для этой цели в Java придуманы две специальные функции.
Первая из них называется `equals`, она имеет объект-получатель,
принимает ещё один объект как параметр и выдаёт результат `true`, если эти два объекта равны.
Пример переопределения `equals` мы увидим в разделе 7.

Вторая функция называется `toString`. Она также имеет объект-получатель, но не имеет параметров.
Её результат -- это строковое представление объекта.
Например:

[source,kotlin]
----
class Square(val column: Int, val row: Int) {
    override fun toString() = "$row - $column"
}
----

Запустив главную функцию выше, мы увидим на консоли строку `6 - 3`.
Обратите внимание на модификатор `override` перед определением `toString()`.
Он указывает на тот факт, что данная функция __переопределяет__ строковое представление по умолчанию.
Подробнее об этом опять-таки в разделе 7.

О других возможностях классов с данными можно прочитать здесь: https://kotlinlang.org/docs/reference/data-classes.html.

== Включение классов

Система __классов__ была бы очень неполноценной, если бы нам приходилось использовать классы сами по себе,
в отрыве друг от друга.
Поэтому у классов есть множество способов взаимодействовать друг с другом.
Самый простой из них -- включение объекта одного класса внутрь другого класса. Например:

[source,kotlin]
----
data class Triangle(val a: Point, val b: Point, val c: Point) {
    // ...
}
----

Здесь треугольник имеет три свойства `a`, `b` и `c`, каждое из которых, в свою очередь, имеет тип `Point` -- точка.
В таких случаях говорят, что треугольник включает три точки, состоит из трёх точек или описывается тремя точками.
Точки, в свою очередь, описываются двумя вещественными координатами. Например:

[source,kotlin]
----
fun main(args: Array<String>) {
    val t = Triangle(Point(0.0, 0.0), Point(3.0, 0.0), Point(0.0, 4.0))
    println(t.b.x) // 3.0
}
----

При вызове `println` мы прочитали свойство `x` СВОЙСТВА `b` треугольника `t`.
Для этого мы дважды использовали точку для обращения к свойству объекта.

Решим с помощью классов `Point` и `Triangle` следующую задачу.
Пусть имеется треугольник ABC, заданный координатами вершин, и точка P.
Необходимо определить, лежит ли точка внутри треугольника.

[source,kotlin]
----
data class Triangle(val a: Point, val b: Point, val c: Point) {

    fun halfPerimeter() = (a.distance(b) + b.distance(c) + c.distance(a)) / 2.0

    fun area(): Double {
        val p = halfPerimeter()
        return Math.sqrt(p * (p - a.distance(b)) * (p - b.distance(c)) * (p - c.distance(a)))
    }

    fun contains(p: Point): Boolean {
        val abp = Triangle(a, b, p)
        val bcp = Triangle(b, c, p)
        val cap = Triangle(c, a, p)
        return abp.area() + bcp.area() + cap.area() <= area()
    }
}
----

Для решения задачи нам потребовалось определить три новых функции в классе `Triangle`.

Пойдём от простого к сложному.
Функция `halfPerimeter()` считает **полупериметр** треугольника, то есть половину его периметра.
Для этого мы считаем длину отрезков AB, BC и CA, суммируем эти длины и делим результат пополам.
Длина отрезка AB (например) считается как `a.distance(b)` -- мы используем ранее определённую функцию точки `distance`.

Функция `area()` считает **площадь** треугольника, используя для этой цели формулу Герона:
`S^2^ = p(p - AB)(p - BC)(p - CA)`.
Здесь `S` -- площадь, `p` -- полупериметр, `AB`, `BC` и `CA` -- длины сторон.
Для расчёта полупериметра мы используем уже готовую функцию `halfPerimeter()`.

Наконец, функция `contains()` решает исходную задачу, то есть определяет,
находится ли точка, заданная параметром `p`, внутри треугольника-получателя.
Для этой цели, кроме уже существующего треугольника-получателя `ABC`,
мы создаём три других: `ABP`, `BCP`, `CAP` и считаем площади всех четырёх треугольников.
Проверьте, что в случае присутствия точки `P` внутри треугольника должно выполняться равенство:
`S(ABC) = S(ABP) + S(BCP) + S(CAP)`.
Это становится очевидно, если нарисовать все эти треугольники.

== Упражнения

Откройте файл `srс/lesson6/task1/Geometry.kt` в проекте `KotlinAsFirst`.
Посмотрите на задачи в нём. Кроме уже рассмотренного класса `Point`,
в данном уроке используются классы `Circle` (окружность), `Segment` (отрезок), `Line` (прямая).
Попробуйте порешать задачи данного урока; рекомендуется делать это последовательно, от простого к сложному,
с проверкой правильности решения каждой из задач с помощью тестов.
Тесты, как и всегда, находятся в `test/lesson6/task1/Tests.kt`

Пройдите в этой группе задач так далеко, как сможете.
Рекомендуется попробовать решить одну из двух очень сложных задач в конце файла.
Если у вас возникают сложности с придумыванием алгоритма решения задачи, обсудите алгоритм с преподавателем.

Откройте теперь файл `srс/lesson6/task1/Chess.kt`.
Файл содержит задачи на поиск траектории движения различных шахматных фигур из клетки в клетку доски --
короля, ладьи, слона, коня. Правила передвижения фигур описаны в комментариях к функциям.

В этом файле рекомендуется решить, по крайней мере, две задачи про одну из фигур
(на определение длины траектории и самой траектории).
Имейте в виду, что поиск траектории для коня достаточно сложен;
прежде, чем приступать к этой задаче, рекомендуется ознакомиться с содержимым раздела 6.5 про поиск пути на графах
и примерами в `src/lesson6/task3/Graph.kt` (этот файл не содержит нерешённых задач).

Переходите к разделу 7.
